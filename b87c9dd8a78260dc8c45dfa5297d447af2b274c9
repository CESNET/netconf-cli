{
  "comments": [
    {
      "key": {
        "uuid": "f6dbc44d_d4b0e4e3",
        "filename": "src/path_parser.hpp",
        "patchSetId": 10
      },
      "lineNbr": 80,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2020-05-05T17:49:58Z",
      "side": 1,
      "message": "This is not hit by any test case. Looks like it should be covered if you add an RPC node to a tab-completion test.",
      "revId": "b87c9dd8a78260dc8c45dfa5297d447af2b274c9",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0edc95ef_4bd8a41d",
        "filename": "src/path_parser.hpp",
        "patchSetId": 10
      },
      "lineNbr": 80,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2020-05-06T00:27:06Z",
      "side": 1,
      "message": "It can\u0027t be covered in the tab-completion test, because the test uses StaticSchema. StaticSchema can\u0027t deal with RPC nodes. And that\u0027s because I don\u0027t support RPC nodes whatsoever (outside yangschema, kind of)",
      "parentUuid": "f6dbc44d_d4b0e4e3",
      "revId": "b87c9dd8a78260dc8c45dfa5297d447af2b274c9",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "855a2c59_d780d526",
        "filename": "src/path_parser.hpp",
        "patchSetId": 10
      },
      "lineNbr": 80,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2020-05-06T09:27:16Z",
      "side": 1,
      "message": "I understand, but I think this should be changed. Now that the code was extended and the \"real\" YangSchema can and does return RPCs (and others), it makes sense to extend the StaticSchema with support for at least the RPCs as well. It could be very simple:\n\n StaticSchema s;\n s.addRpc(\"/example:launch-nukes\");\n s.addContainer(\"/example:launch-nukes/input\");\n s.addLeaf(\"/example:launch-nukes/input/megatons\", ...);\n s.addContainer(\"/example:launch-nukes/output\");\n s.addLeaf(\"/example:launch-nukes/output/mushroom-cloud-height\", ...);\n\nI think it\u0027s OK to keep the \"special containers\" \"input\" and \"output\" as they are in libyang. The downside is that callers would have to know how to work with them, but the advantage is that one can use availableNodes() to query RPC\u0027s input and output parameters. An alternative would be making this explicit via two new methods, inputNodes(std::string path) and outputNodes(std::string path).\n\nAre you OK with making this change in the StaticSchema?",
      "parentUuid": "0edc95ef_4bd8a41d",
      "revId": "b87c9dd8a78260dc8c45dfa5297d447af2b274c9",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a089c861_27ba8190",
        "filename": "src/path_parser.hpp",
        "patchSetId": 10
      },
      "lineNbr": 80,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2020-05-06T19:08:44Z",
      "side": 1,
      "message": "This seems like a weird idea, to support any more of rpc stuff right now. The support is mainly driven by what the parser supports. So to support something I need to extend the parser AST with structs like `rpc_`. If I implemented what you suggest, it would mean adding something, that isn\u0027t really a feature. The entire Add more types to YangSchema::nodeType change is about adding the least amount of stuff, so that my node parser rework can work. Imho it makes little sense to add any more support just so that we can be sure that the code here really ignores rpcs/leaflist/whatever. I\u0027m fine with adding a FIXME here that will be resolved when support for rpcs/leaflist/whatever gets added.",
      "parentUuid": "855a2c59_d780d526",
      "revId": "b87c9dd8a78260dc8c45dfa5297d447af2b274c9",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aa3d2744_3d42b1d8",
        "filename": "src/path_parser.hpp",
        "patchSetId": 10
      },
      "lineNbr": 80,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2020-05-06T21:38:10Z",
      "side": 1,
      "message": "This project is using the StaticSchema as a mock data provider. Given that the *real* data provider returns these \"extended\" data, in my opinion it makes a lot of sense to test how the consumers deal with these unsupported pieces of data. Extending the mock in the simplest possible manner is an obvious approach, IMHO.\n\nBut I won\u0027t force this upon you of course, so let\u0027s merge this one as-is. I\u0027ll push a followup change for this one.",
      "parentUuid": "a089c861_27ba8190",
      "revId": "b87c9dd8a78260dc8c45dfa5297d447af2b274c9",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3cd98748_a1a9b4c7",
        "filename": "src/path_parser.hpp",
        "patchSetId": 10
      },
      "lineNbr": 80,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2020-05-06T22:20:05Z",
      "side": 1,
      "message": "Yes, StaticSchema has the same interface as YangSchema, but its purpose is testing the parser. IMHO, if StaticSchema were to get some sort of rpc support, it should only be because the parser got some of that support too and I want to test the parser through StaticSchema. In other words - the parser is designed with whatever YANG has, and StaticSchema is designed after whatever the parser supports. I do understand that there is some value in having the above code covered with tests, but I don\u0027t think it\u0027s really that big of a deal, since the test wouldn\u0027t be covering any (new) features (because the parser doesn\u0027t support any of these nodes).",
      "parentUuid": "aa3d2744_3d42b1d8",
      "revId": "b87c9dd8a78260dc8c45dfa5297d447af2b274c9",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68",
      "unresolved": false
    }
  ]
}