{
  "comments": [
    {
      "key": {
        "uuid": "fb0a48c4_100afe03",
        "filename": "src/leaf_data.hpp",
        "patchSetId": 18
      },
      "lineNbr": 195,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2020-04-02T13:34:54Z",
      "side": 1,
      "message": "I\u0027m getting lost here (which is not to say that the code is wrong, it\u0027s just confusing to me).\n\nHow come that it is necessary to set ParserContext::m_leafType when parsing `enum` and `identityref` -- why are these two special? Why is it not required when handling \"boring primitive types\" such as int8? Why is it not necessary for a `leafref`?\n\nI went through the code and I think that it\u0027s because ParserContext::m_leafType is only ever used in createSetSuggestions_class\u003cT\u003e specializations for these two types. That feels a bit weird.\n\nRight now there are no unions, so I think each leaf can only possibly ever have just one type. This probably means that whenever the type info for a leaf XPath is needed (i.e., creating suggestions), the type info can be queried from the ParserContext.m_schema once again, right? If so, my preference is to remove ParserContext::m_leafType from this commit. When you reintroduce it for unions, please use a more descriptive name such as \"leafFinalType\", and make sure that its setting is \"uniform\", i.e. probably from outside of this visitor or from each and every overload.",
      "range": {
        "startLine": 185,
        "startChar": 0,
        "endLine": 195,
        "endChar": 86
      },
      "revId": "8b2f894eab72b1bb119dbc32ce744fd10dc8c54d",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b064a997_96b8a20d",
        "filename": "src/leaf_data.hpp",
        "patchSetId": 18
      },
      "lineNbr": 195,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2020-04-02T18:53:43Z",
      "side": 1,
      "message": "These are special, becuase I check in the on_success handler if the enum/identityref is valid. I guess I could just check the value inside this visitor and get rid of any assignment. To be honest, there probably isn\u0027t any value in using the on_success handler for this.",
      "parentUuid": "fb0a48c4_100afe03",
      "range": {
        "startLine": 185,
        "startChar": 0,
        "endLine": 195,
        "endChar": 86
      },
      "revId": "8b2f894eab72b1bb119dbc32ce744fd10dc8c54d",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "556a16f7_ae63c98a",
        "filename": "src/leaf_data_type.hpp",
        "patchSetId": 18
      },
      "lineNbr": 65,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2020-04-02T13:40:12Z",
      "side": 1,
      "message": "If this is just an XPath, then this type info cannot be fully used \"standalone\", and one needs a callout to Schema to query the target\u0027s ultimate type. Would it perhaps make more sense to stash something like this here as well?\n\n  LeafDataType targetType;\n\n(and perhaps s/m_pointsTo/targetXPath/)",
      "revId": "8b2f894eab72b1bb119dbc32ce744fd10dc8c54d",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1a08e47c_21c7e297",
        "filename": "src/leaf_data_type.hpp",
        "patchSetId": 18
      },
      "lineNbr": 65,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2020-04-02T18:53:43Z",
      "side": 1,
      "message": "This:\n\n struct LeafRef;\n\n using LeafDataType \u003d std::variant\u003c\n  ...\n \u003e;\n\n struct LeafRef {\n     bool operator\u003d\u003d(const LeafRef\u0026 other) const;\n     std::string m_targetXPath;\n     LeafDataType m_targetType;\n };\n\ndoesn\u0027t work unfortunately, I would have to do std::unique_ptr\u003cLeafDataType\u003e.",
      "parentUuid": "556a16f7_ae63c98a",
      "revId": "8b2f894eab72b1bb119dbc32ce744fd10dc8c54d",
      "serverId": "e32f8df8-3db0-4f76-a6c6-fe9d6e69dd68",
      "unresolved": true
    }
  ]
}